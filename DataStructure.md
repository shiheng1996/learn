# 排序算法
## 冒泡排序
### 思想 
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
### 实现步骤
- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。
## 插入排序
### 思想
我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
### 实现步骤
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。
## 选择排序
### 思想
选择排序(Selection Sort)的原理有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从排序区间中找到最小的元素，将其放到已排序区间的末尾。
### 实现步骤
1. 接下来找到未排序区间的最小值的下标
2. 交换未排序区间最小元素和当前元素的位置
3. 重复1-2步骤直到未排序区间为0
# 树：         
## 二叉树
每个节点最多有两个“叉”，也就是两个子节点，分别是左子节
点和右子节点。
### 完全二叉树
叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后
一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。
### 满二叉树
叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，
这种二叉树就叫作满二叉树。
### 二叉查找树
- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值;
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值;
- 任意节点的左、右子树也分别为二叉查找树;
- 没有键值相等的节点。
### 平衡二叉树 平衡二叉查找树 AVL
- 非叶子节点最多拥有两个子节点；
- 非叶子节值大于左边子节点、小于右边子节点；
- 树的左右两边的层级数相差不会大于1;
- 没有值相等重复的节点;
#### 特点
- 一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1) 
- 一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)). 
- 一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).
### 红黑树
#### 定义
红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：
#### 特点
- 节点是红色或黑色。
- 根是黑色。
- 所有叶子都是黑色（叶子是NIL节点）。
- 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
- 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点
![image](file:///Users/shiheng/Documents/RedBlackTree.PNG)
#### 与AVL树比较
红黑树是牺牲了严格的高度平衡的优越条件为代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.
#### 应用
- 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块
- epoll在内核中的实现，用红黑树管理事件块
- nginx中，用红黑树管理timer等
- Java的TreeMap HashMap实现
## 多路查找树
### B树 平衡多路查找树

