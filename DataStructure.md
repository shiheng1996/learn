# 排序算法
## 冒泡排序
### 思想 
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
### 实现步骤
- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。
## 插入排序（分区，插入合适位置）
### 思想
我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
### 实现步骤
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。
## 希尔排序（增量分组）
### 思想
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含
的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止
## 选择排序（分区，找最小值插入未分区尾）
### 思想
选择排序(Selection Sort)的原理有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从排序区间中找到最小的元素，将其放到已排序区间的末尾。
### 实现步骤
1. 接下来找到未排序区间的最小值的下标
2. 交换未排序区间最小元素和当前元素的位置
3. 重复1-2步骤直到未排序区间为0
## 归并排序（分治思想，二分划分）
### 原理
先分解再合并
归并排序(Merge Sort)的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。归并排序使用的分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。分治思想跟我们前面讲的递归思想很像，分治算法一般都是用递归来实现的。分治是一种解决问题
### 算法描述
出归并排序的递归公式
mergeSort(m->n) = merge(mergeSort(m->k),mergeSort(k+1->n));当 m=n 时终止
我们来解释一下这个公式：我们要对 m->n 之间的数列进行排序，其实可以拆分成
对 m->k 之间的数列进行排序，以及对 k+1->n 之间的数列排序，然后将连个拍好
序的数列进行合并就称为了最终的数列，同样的道理，每一段数列的排序又可以继
续往下拆分，形成递归。
算法描述：
• 把长度为 n 的输入序列分成两个长度为 n/2 的子序列；
• 对这两个子序列分别采用归并排序；
• 将两个排序好的子序列合并成一个最终的排序序列。
## 快速排序（分治思想，找pivot基准）
### 原理
快速排序(Quick Sort)算法，简称快排，利用的也是分治的思想，初步看起来有点
像归并排序，但是其实思路完全不一样，快排的思路是：如果要对 m->n 之间的数
列进行排序，我们选择 m->n 之间的任意一个元素数据作为分区点(Pivot)，然后我
们遍历 m->n 之间的所有元素，将小于 pivot 的元素放到左边，大于 pivot 的元素
放到右边，pivot 放到中间，这样整个数列就被分成三部分了，m->k-1 之间的元素
是小于 pivot 的，中间是 pivot，k+1->n 之间的元素是大于 pivot 的。然后再根据
分治递归的思想处理两边区间的的元素数列，直到区间缩小为 1，就说明整个数列
都已有序了。
### 实现步骤
1. 从数列中挑出一个元素，称为 “基准”（pivot）
2. ***重点*** 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
## 桶排序（按值域划分成多个桶，对每个桶进行排序）
### 原理
桶排序(Bucket Sort)顾名思义，会用到“桶”，桶我们可以将其想象成一个容器，核
心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。
桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的
了，换句话说：桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中，
也就是根据元素值特性将集合拆分为多个区域，则拆分后形成的多个桶，从值域上
看是处于有序状态的。对每个桶中元素进行排序，则所有桶中元素构成的集合是已
排序的。
### 实现步骤
1.  元素值域的划分，也就是元素到桶的映射规则。映射规则需要根据待排序集合
的元素分布特性进行选择，若规则设计的过于模糊、宽泛，则可能导致待排序
集合中所有元素全部映射到一个桶上，若映射规则设计的过于具体、严苛，则
可能导致待排序集合中每一个元素值映射到一个桶上。
2. 单个桶内元素排序，从待排序集合中元素映射到各个桶上的过程，并不存在元素的比较和交换操
作，在对各个桶中元素进行排序时，可以自主选择合适的排序算法，每个桶内
的排序算法的复杂度和稳定性，决定了最终的算法的复杂度和稳定性
### 特点
***空间换时间***
桶排序比较适合用在非内存排序中。所谓的非内存排序就是说数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。此外由桶排序的过程可知，当待排序集合中存在元素值相差较大时，对映射规则的选择是一个挑战，有时可能导致元素集中分布在某一个桶中或者绝大多数桶是空桶的现象，对算法的时间复杂度或空间复杂度有较大影响，所以桶排序适用于元素值分布较为集中的序列，或者说待排序的元素能够均匀分布在某一个范围[MIN, MAX]之间。
## 计数排序（按最大值m划分成m个桶，桶中存相同元素个数）
### 原理
计数排序(Counting Sort) 使用了一个额外的数组 C，其中第 i 个元素是待排序数组
A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。
其实计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并
不大的时候，比如最大值是 m，我们就可以把数据划分成 m 个桶(其实是个数
组)。每个桶内的数据值都是相同的，省掉了桶内排序的时间。每个桶内存储的也
不是待排序的数据而是待排序数组 A 中值等于某个值的元素个数。
### 实现步骤
1. 找出待排序的数组中最大和最小的元素；
2. 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
3. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
4. 反向填充目标数组：将每个元素 i 放在新数组的第 C(i)项，每放一个元素就将 C(i)减去 1。
### 适用场景
计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大
很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排
序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。
## 基数排序（按个位十位百位排序）
### 原理
也是桶排序的一种特殊情况。
将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
### 实现步骤
1. 数据位树补齐，保证每个数据具有相同的位数
2. 比较每个数据的个位数，利用计数排序算法（小范围数据的特性）排序，然后取出 再比较十位数 百位数等等
### 特点
1. 基数排序是对传统桶排序的扩展，速度很快.
2. 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。
3. 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些
记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前，
则称这种排序算法是稳定的;否则称为不稳定的]
## 堆排序
### 原理
堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有
要求结点的左孩子的值和右孩子的值的大小关系。每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。反之称为大顶堆，一般升序采用大顶堆，降序采用小顶堆。
### 实现步骤
1. 将待排序序列构造成一个大顶堆
2. 此时，整个序列的最大值就是堆顶的根节点。
3. 将其与末尾元素进行交换，此时末尾就为最大值。
4. 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。
# 查找算法
## 二分查找法 
### 
# 树     
## 二叉树
每个节点最多有两个“叉”，也就是两个子节点，分别是左子节
点和右子节点。
### 二叉树的遍历
1. 前序：先输出父节点，再输出左子树，再输出右子树
2. 中序：先输出左子树，再输出父节点，再输出右子树
3. 后序：先输出左子树，再输出右子树，再输出父节点
### 完全二叉树 
叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后
一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。
***堆排序使用完全二叉树实现***
### 满二叉树
叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，
这种二叉树就叫作满二叉树。节点总数位2^n-1 n为树的高度 
### 二叉查找树
- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值;
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值;
- 任意节点的左、右子树也分别为二叉查找树;
- 没有键值相等的节点。
### 平衡二叉树 平衡二叉查找树 AVL
- 非叶子节点最多拥有两个子节点；
- 非叶子节值大于左边子节点、小于右边子节点；
- 树的左右两边的层级数相差不会大于1;
- 没有值相等重复的节点;
#### 特点
- 一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1) 
- 一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)). 
- 一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).
### 红黑树
#### 定义
红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：
#### 特点
- 节点是红色或黑色。
- 根是黑色。
- 所有叶子都是黑色（叶子是NIL节点）。
- 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
- 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点
![image](file:///Users/shiheng/Documents/RedBlackTree.PNG)
#### 与AVL树比较
红黑树是牺牲了严格的高度平衡的优越条件为代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.
#### 应用
- 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块
- epoll在内核中的实现，用红黑树管理事件块
- nginx中，用红黑树管理timer等
- Java的TreeMap HashMap实现
### 赫夫曼树
#### 定义
1. 结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积）
2. 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path
length)
3. 赫夫曼树HuffmanTree: 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小的树 ,权值越大的结点离根结点越近的二叉树才是最优二叉树。
### 赫夫曼编码
## 多路查找树
### B树 平衡多路查找树
#### 定义
一个 m 阶的B树是一个有以下属性的树：
- 每个节点最多有m-1个关键字（可以存有的键值对）。
- 根节点最少可以只有1个关键字。
- 非根节点至少有m/2个关键字。
- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
- 每个节点都存有索引和数据，也就是对应的key和value
所以，根节点的关键字数量范围：1 <= k <= m-1，非根节点的关键字数量范围：m/2 <= k <= m-1。
描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。
#### 特点
### B+树
#### 定义
1. 根节点至少一个元素
2. 非根节点元素范围：m/2 <= k <= m-1
3. 非叶子节点不存储数据，只存储索引；叶子节点存储数据
4. 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
5. 父节点存有右孩子的第一个元素的索引
1 2 为b树共同点，3 4 5 为不同点
### B*树
#### 定义
1. B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针。
2. B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的
1/2。
3. 从第2个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高

