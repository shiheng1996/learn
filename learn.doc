
数据库
MongoDB:
简述
MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。

概念
数据库 database 、集合(表) collection 、文档 (一条记录) doc 、域 (字段) filed 
、主键 primaryKey 默认_id为主键、索引 index

整合java
Springboot整合MongoDB  注入 MongoTemplate ,使用其内部方法
实体类 使用注解 @Document(collection="user") 

关系型数据库
事务四大特性ACID
事务的原子性(Atomicity)：
指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.
事务的一致性(Consistency)：
指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.
独立性(Isolation）:
事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.
持久性(Durability）:
事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.
事务的并发问题
更新丢失
当两个事务选择同一行，然后更新数据，由于每个事务都不知道其他事务的存在，就会发生丢失更新的问题，（你我同时读取同一行数据，进行修改，你commit之后我也commit，那么我的结果将会覆盖掉你的结果）。

脏读
一个事务正在对一条记录做修改，在这个事务提交之前，别的事务读取到了这个事务修改之后的数据，也就是说，一个事务读取到了其他事务还没有提交的数据，就叫做脏读。

不可重复读
一个事务读某条数据读两遍，读到的是不一样的数据，也就是说，一个事务在进行中读取到了其他事务对旧数据的修改结果，（比如说 我开一个事务 修改某条数据 先查后改 执行修改动作的时候发现这条数据已经被别的事务删掉了）

幻读
一个事务中，读取到了其他事务新增的数据，仿佛出现了幻象。（幻读与不可重复读类似，不可重复读是读到了其他事务update/delete的结果，幻读是读到了其他事务insert的结果）
事务的隔离级别
Read uncommitted
读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。
事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。
分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。
Read committed 读提交，能解决脏读问题。
Read committed
读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。
事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）,程序员就会很郁闷，明明卡里是有钱的
分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。
Repeatable read
重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。
分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
什么时候会出现幻读？
事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。
那怎么解决幻读问题？Serializable！
Serializable 序列化
Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

oracle与mysql 的区别
	Mysql	Oracle
分页	使用limit	使用RowNum
字符串	使用双引号包起来	单引号
对事务的支持	默认不支持
使用InnoDb存储引擎才支持事务	完全支持
事务提交方式	默认自动提交	需要手动提交
默认的事务隔离级别	REPEATABLE-READ
可以解决 脏读、不可重复度	READ COMMITTED
可解决脏读
自动增长的数据类型处理	支持自增	需要建立一个自动增长的序列号，插入记录时要把序列号的下一个值赋于此字段
字符串的模糊比较	使用like 	使用like,但不能使用索引,不快
使用instr 函数 更快

mysql
mysql 锁机制使用

1.	查询语句后增加for update   (仅仅使用InnoDB引擎)   (悲观锁)
在不通过索引条件查询的时候，InnoDB 的for update确实使用的是表锁，而不是行锁。锁住的记录不能读写
1.	表增加version字段  (乐观锁)
锁住的记录可读
Mybatis 框架
$与#  ${}是字符串拼接 #{}可以防止sql注入
Mysql优化
1.	分库分表
(1)	垂直拆分是根据业务将一个库（表）拆分为多个库（表）。如：将经常和不常访问的字段拆分至不同的库或表中。由于与业务关系密切，目前的分库分表产品均使用水平拆分方式。

(2)	水平拆分(常用)则是根据分片算法将一个库（表）拆分为多个库（表）。如：按照ID的最后一位以3取余，尾数是1的放入第1个库（表），尾数是2的放入第2个库（表）等。
(3)	使用Sharding-JDBC进行水平拆分,配置多数据源,根据分库分表算法进行拆分
2.	Sql语句优化
(1)	使用查询缓存优化查询,查询时减少使用CURDATE() 、NOW()、RAND() 函数,因为其不会开启查询缓存
(2)	使用EXPLAIN 关键字检测查询 ,做出对应的处理
(3)	当只要一行数据时,sql语句后加上Limit 1
(4)	为搜索字段增加索引
(5)	在join表的时候使用相当类型的列，并将其索引
(6)	优先使用ENUM, 字段的取值是有限而且固定的,优先使用ENUM
(7)	避免使用SELECT *,尽量使用列名
(8)	模糊查询like  %不要用在最左边
应用
1.	解决redis缓存和mysql数据不一致问题
问题描述: 在主从同步，读写分离的数据库架构下，有可能出现脏数据入缓存的情况，此时串行化方案不再适用了
设置主从同步延迟为1s
(1)	双缓存淘汰法
先淘汰缓存,在写入数据库,往消息总线esb发送一个淘汰消息,发送立即返回.写请求的处理时间几乎没有增加.
在消息总线下游有一个异步淘汰缓存的消费者,在拿到淘汰消息1s后淘汰缓存.这样即使在1s内有脏数据入缓存,也能够被淘汰掉.
(2)	读binlog异步淘汰缓存
新增一个线下的读取binlog的异步淘汰缓存模块,读取binlog总的数据,然后进行异步淘汰
面试
1.	on和where 的区别
在连接表查询之后 跟on和where 是有区别的
(1)	on不会影响查询的总条数,只会影响展示的列的内容
(2)	where 会影响查询的总条数
2.	索引
(1)	分类:
Normal
UNIQUE
PRIMARY
FULLTEXT  全文索引:用于搜索很长一篇文章的时候，效果最好
联合索引(最左前缀匹配,只有出现最左边的列,才会触发联合索引)
(2)	方法
HASH
仅支持"=","IN"和"<=>"精确查询，不能使用范围查询,由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash

BTREE
B-Tree是最常见的索引类型，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）
B-Tree在MyISAM里的形式和Innodb稍有不同：
MyISAM表数据文件和索引文件是分离的，索引文件仅保存数据记录的磁盘地址
InnoDB表数据文件本身就是主索引，叶节点data域保存了完整的数据记录

Redis
数据结构
String 、hash、set(集合)、zset(无序集合)、list(列表)
持久化
1.	RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。
2.	AOF, 默认不开启,它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
Redis分布式锁
Setnx命令 设置 key的过期时间,如果key存在返回0
对应springboot 的redistemplate的opsforvalue().setifabsent()方法
Redis为什么能快速执行
(1) 绝大部分请求是纯粹的内存操作（非常快速）
(2) 采用单线程,避免了不必要的上下文切换和竞争条件
(3) 非阻塞IO - IO多路复用
消息队列
Rocketmq
简介
RocketMQ作为一款纯java、分布式、队列模型的开源消息中间件，支持事
务消息、顺序消息、批量消息、定时消息、消息回溯等。
专业术语
名称	用途
Producer	消息生产者
Producer Group	多个发送同一类消息的生产者称之为一个生产者组
Consumer	消息消费者
Consumer Group	消费同一类消息的多个 consumer 实例组成一个消费者组
Topic	一级消息类型,标题
Tag	二级消息类型,标签
keys	Message索引键，多个用空格隔开，RocketMQ可以根据这些key快速检索到消息对消息关键字的提取方便查询，比如一条消息某个关键字是 运单号，之后我们可以使用这个运单号作为关键字进行查询
Message	消息载体, 一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息
Broker
	Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。
NameServer	用于管理所有Broker节点信息，接收Broker的注册/注销请求，此外还记录了Topic与Broker、Queue的对应关系，Broker主备信息

Springboot 整合rabbitmq
1.	发送消息
创建producer
DefaultMQProducer设置name或 groupname、nameserver地址、实例名称
producer.start()方法 开启生产者
创建message对象
设置消息体、topic、tag、keys
producer.send()方法发送消息
2.	消费消息
	创建consumer
DefaultMQConsumer设置(set) 
name或 groupname、nameserver地址、实例名称、消息模式
consumer.subscribe(topic,tag)
consumer .registerMessageListener()触发consumeMsgCallback.onRecive(messages)


消息消费模式
　　　集群模式：默认模式，主题下的同一条消息只允许被其中一个消费者消费,消费进度存储在服务端
广播模式：主题下的同一条消息将被集群内的所有消费者消费一次,消费进度存储在消费者本地
搜索引擎
ElasticSearch与Solr的区别

	ElasticSearch	Solr
分布式管理	Elasticsearch 自身带有分布式协调管功能;	Solr利用 Zookeeper 进行分布式管理
数据格式	仅支持json文件格式	Solr 支持更多格式的数据
搜索效率	实时搜索好,即创建索引的同时进行搜索	当单纯的对已有数据进行搜索时，Solr更快
当实时建立索引时, Solr会产生io阻塞，查询性能较差 。
使用
数据概念
一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式，比如我们打算插入一条记录，可以简单发送一个HTTP的请求
Spring data 整合 es或solr
JAVA
基础
面对对象
1.	理解:
面向对象是向现实世界模型的自然延伸，这是一种”万物皆对象”的编程思想。在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例。 
2.	特征:
封装
将一类事物的属性和行为抽象成一个类，一般是使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化。
继承
基于已有的类的定义为基础，构建新的类，已有的类称为父类，新构建的类称为子类，子类能调用父类的非private修饰的成员，同时还可以自己添加一些新的成员，扩充父类，甚至重写父类已有的方法，更其表现符合子类的特征。
多态
方法的重写、重载与动态连接构成多态性。如果说封装和继承是为了使代码重用，那么多态则是为了实现接口重用。多态的一大作用就是为了解耦–为了解除父子类继承的耦合度。如果说继承中父子类的关系式IS-A的关系，那么接口和实现类之之间的关系式HAS-A。简单来说，多态就是允许父类引用(或接口)指向子类(或实现类)对象。很多的设计模式都是基于面向对象的多态性设计的。
设计模式
1.	单例模式:
饿汉式
 
懒汉式
 
双重检查锁 的懒汉式
 
Initialization on Demand Holder
 
多线程、高并发
1.	多线程同步的实现方式
Synchronized关键字
ReentrantLock  重入锁
ThreadLocal 线程变量
LinkedBlockingQueue 阻塞队列
2.	配置线程池
 

3.	使用多线程
方法上加@Async("asyncServiceExecutor")  里面为线程池名称
4.	线程生命周期
1.	NEW
线程还没有调用start的时候
2.	RUNNABLE
JVM启动了这个任务
3.	BLOCKED
线程被锁的时候，线程等待进去一个synchronized块方法或者可重入锁的时候
4.	WAITING
线程调用object.wait() 或thread.join()或 LockSupport.park() 的时候变成 WAITING
5.	TIMED_WAITING
sleep()或者wait(),join()带时间参数等方法时
6.	TERMINATED
线程执行完成 或者被中断的时候变成TERMINATED 
 
5.	线程池的四种类型

1.	Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务
2.	Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。
3.	Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行
4.	创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。


6.	并发编程的三大特性
1.	原子性
提供互斥访问,同一时刻只能有一个线程对数据进行操作
Synchronized 、automic
2.	可见性
一个线程对主内存的修改，其他线程能够立即看得。
Synchronized、volatile
3.	有序性
即程序执行的顺序按照代码的先后顺序执行。
7.	线程变量ThreadLocal
使用:
Threadlocal为每个线程提供独立的变量副本,而不会影响其他线程所对应的副本.可以创建多个线程变量
使用场景:
适用于无状态,副本变量独立后不影响业务逻辑的高并发场景. 例如数据库连接管理、线程会话session管理、
RocketMQUtil工具类使用ThreadLocal存放producer和consumer

        
数据结构
基本数据结构
1.	数组
优点:
1、按照索引查询元素速度快 
2、按照索引遍历数组方便
缺点:
1、	数组的大小固定后就无法扩容了 
2、数组只能存储一种类型的数据 
3、添加，删除的操作慢，因为要移动其他的元素。
常用数据结构
1.	ArrayList
底层: 数组
第一次添加默认长度 10
扩容机制 1.5倍
每次增加都会使用 Arrays.copyof()创建一个新数组
优点:查询快
缺点:增删慢,线程不安全
2.	CopyOnWriteArraylist
线程安全
3.	HashMap
底层:数组+链表
扩容机制2倍
加载因子0.75
key和value都可以为null
线程不安全
put(k,v)原理:通过key的hash值得到数组下标，然后把entry插到该数组，假如有两个不同的key被分到相同的下标，也就是哈希冲突，那么该数组在该下标下就会形成链表
4.	ConcurrentHashMap
线程安全

关键字
final
(1)	被final关键字修饰的类不能被继承
(2)	被final 修饰的基础类型变量的值不能被修改
(3)	被final 修饰的引用类型变量的引用(内存地址)不能被修改,引用指向的对象是可以修改的

transient(被修饰的变量不被序列化)
(1)	变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
(2)	transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口
(3)	被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。
volatile(保证并发编程中变量的可见性)
一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取
集合排序
内部比较器
内部比较器就是把比较器定义在实体类的内部，这是要实现的接口为Comparable,重写compareTo,实现包含实体类对象的集合的排序时，调用的是Collections.sort(list).
外部比较器
外部比较器，实现Comparator,重写compare。排序时调用的函数是Collections.sort(list,比较器)。
反射机制
概念
在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
利用反射机制创建对象
1.	获取Class对象的三种方式
(1)	Class.forName(全限定类名)
(2)	Hero.class
(3)	new Hero().getClass()
2.	获取构造器对象
Constructor con = clazz.getConstructor(形参.class);
3.	获取对象
Hero hero =con.newInstance(实参);
使用场景
数据库注册驱动
AOP动态代理
面试
hashcode()与equals()
(1)	在哈希表中才有用,其他地方没用
(2)	哈希冲突: hashcode() 相等,equals不相等
(3)	hashcode()作用: hashCode()的存在主要是用于查找的快捷性
如Hashtable，HashMap等，HashCode经常用于确定对象的存储地址；
(4)	equals()作用:hashmap使用equals()判断当前键是否与表中存在的键相同
String类型的内部实现方式 , 为什么string 不可变
 
在JDK7中，只有一个value变量，也就是value中的所有字符都是属于String这个对象的。这个改变不影响本文的讨论。 除此之外还有一个hash成员变量，是该String对象的哈希值的缓存，这个成员变量也和本文的讨论无关。在Java中，数组也是对象。 所以value也只是一个引用，它指向一个真正的数组对象。其实执行了String s = “ABCabc”; 这句代码之后，真正的内存布局应该是这样的：
 
spring
AOP实现原理 :动态代理
jdk代理
1.	概念
利用反射机制
JDK动态代理只能对实现了接口的类生成代理，而不能针对类
2.	实现
实现InvocationHandler接口
 
cglib动态代理
1.	概念
利用ASM(开源的java字节码编辑库,操作字节码),将代理对象 类的class文件加载出来,通过修改其字节码生成子类来处理

用CGlib生成代理类是目标类的子类
2.	实现
实现MethodInterceptor接口
 
