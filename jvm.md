# JVM 内存结构
## 1.程序计数器 
### 定义: 
Program Counter Register  
物理上对应寄存器
### 作用: 
记住下一条jvm指令的执行地址
### 特点: 
* 线程私有
* 不会存在内存溢出
## 2.虚拟机栈 JVM Stacks  
(栈 先进后出)
### 定义
* 每个线程运行时所需要的内存,称为虚拟机栈
* 每个栈由多个栈帧(Frame)组成,栈帧对应对着每次方法调用时所占用的内存
* 每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法
### 特点: 
* 线程私有
### 问题辨析
1. 垃圾回收是否涉及栈内存？
不涉及
2. 栈内存分配是否越大越好？
不是
3. 方法内的局部变量是否线程安全？
* 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
* 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全问题
### 栈内存溢出
* 栈帧过多 （方法递归调用）
* 栈帧过大
## 3.本地方法栈 Native Method Stacks
### 定义
给本地方法（C 或C++ 实现）的运行提供内存空间
### 特点: 
* 线程私有
## 4.堆 Heap
### 定义
通过new关键字创建的对象都会使用堆内存
### 特点
* 它是线程共享的，堆中对象都需要考虑线程安全的问题
* 有垃圾回收机制
### 组成
#### 新生代
##### 概念
年轻代用来存放新近创建的对象，尺寸随堆大小的增加和减少而相应的变化，默认值是保持为堆的1/15。
年轻代的大小可以通过-xmn设置固定大小，也可以通过-xx:newratio设置年轻代和年老代的比例。
年轻代中存在的对象是死亡非常快的,所以为了提高年轻代的垃圾回收效率，
又将年轻代划分为三个区域: eden区、survivor from 区、survivor to 区 ,默认比例为 Edem : from : to = 8 :1 : 1
##### GC-分代复制算法
新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时(默认为15 通过XX:MaxTenuringThreshold 设置)就会被移动到年老代中。
因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是分代复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。
在GC开始的时候，对象只会存在于Eden区和Survivor From区，Survivor To区是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到To，而From区中仍存活的对象会根据他们的年龄值来决定去向。达到年龄阈值(通过-XX:MaxTenuringThreshold来设置,默认为15)的对象会被移动到年老代中，没有达到阈值的对象会被复制到To区域。经过这次GC后，Eden区和From区已经被清空。这个时候，From和To会交换他们的角色，也就是新的To就是上次GC前的From，新的From就是上次GC前的To。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到To区被填满，To区被填满之后，会将所有对象移动到年老代中。
#### 老年代
### 堆内存溢出
## 5.方法区
### 定义
所有jvm线程共享的区域
存储了跟类的结构的相关信息  
### 组成
* 要加载的类信息
* 静态变量
* final类型的常量、属性和方法信息
* hotspot JVM的持久代(PermanetGeneration)来存放方法区。
### 方法取内存溢出
### 运行时常量池


